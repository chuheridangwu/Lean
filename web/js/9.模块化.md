# 模块化
模块化方案现在常用的有两种，一种是`CommonJS`规范，一种是2015年ES6推出的`ES Modules`

CommonJS 加载模块时同步的，在浏览器中，通常不使用CommonJS规范，* 同步意味着只有等待对应的模块加载完毕，当前模块的内容才能运行。node 使用的是 CommonJS 模块化方案，

`webpack`打包工具具备对CommonJS的支持和转换,它会将我们的代码转成浏览器可以直接执行的代码.

## CommonJS
1. 每个模块内部 `module` 变量代表当前模块
2. module变量是一个对象，它的 `exports` 属性是对象的接口 (既`module.exports`)
3. 使用`require()`加载某个模块时， 其实是加载模块的 `module.exports` 属性

#### module
每个 .js 自定义模块中都有一个module对象，存储了和当前模块有关的信息，在js文件中打印`console.log(module)`结果
```javascript
{
  id: '.',
  path: '/Users/xxx/Desktop/projects/module',
  exports: {},
  filename: '/Users/xxx/Desktop/projects/module/234.js',
  loaded: false,
  children: [
    {
      id: '/Users/xxx/Desktop/projects/module/123.js',
      path: '/Users/xxx/Desktop/projects/module',
      exports: {},
      filename: '/Users/xxx/Desktop/projects/module/123.js',
      loaded: true,
      children: [],
      paths: [Array]
    }
  ],
  paths: [
    '/Users/xxx/Desktop/projects/module/node_modules',
    '/Users/xxx/Desktop/projects/node_modules',
    '/Users/xxx/Desktop/node_modules',
    '/Users/xxx/node_modules',
    '/Users/node_modules',
    '/node_modules'
  ]
}
```

使用 `require()` 方法导入模块时，导入的结果永远以 `modeule.exports` 指向的对象为准,比如下面的代码，导入后只 sayHello 和 nickname
```javascript
var hello = "124"
module.exports.hello = hello

function sayHello(){
    console.log("打招呼");
}

module.exports = {
    sayHello,
    nickname: '小黑'
}
```

导入时可以设置成一个变量
```javascript
let command  = require("./hello.js")

console.log(command.sayHello);
console.log(command.nickname);
```
也可以使用结构的方法解析每个变量
```javascript
const { sayHello, nickname} = require("./hello.js")

console.log(sayHello);
console.log(nickname);
```

#### require(x)
require(x)函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内,它的导入规则
1. 如果有后缀名，按照后缀名的格式查找对应的文件
2. 如果没有后缀名，会按照如下顺序：
   1. 直接查找文件x (带后缀)
   2. 查找x.js (不带后缀)
   3. 查找x.json (不带后缀)
   4. 查找x.node
3. 上述都没有找到，会将x作为一个目录向下查找 x/index.js  index.json index.node 文件。

>使用`npm install axios`安装第三方时，会在文件下生成`node_modules`文件夹，文件夹内包含第三方文件夹`axios`, axios 下有`index.js`文件。所以在其他模块引入时可以找到对应的模块


## ES Modules
ES Module 模块采用`export`和`import`关键字来实现模块化,export 负责将模块内的内容导出,`import`负责从其他模块导入内容。

采用 ES Module 将自动采用严格模式：`use strict`。

#### 使用
浏览器中使用ES6的模块化开发，导入时需要设置`type="module"`,直接在浏览器中运行代码，会报如 CORS 错误,需要通过服务器测试，可以使用VSCode插件：Live Server。
```html
<script src="./hello.js" type="module"></script>
<script src="./use.js" type="module"></script>
```
hello.js内容
```javascript
let name = "hello"
function sayhello(){
    console.log("sayhello");
}
export let age = 20
export{
    name,
    sayhello
}
```
导入模块
```javascript
import {age, name as nickname ,sayhello } from "./es123.js"

console.log(nickname);
console.log(age);
console.log(sayhello);
// name as nickname 起别名，将name改成nickname 
```
如果导入模块后有变量名冲突，可以给导入变量起别名或者对整个模块起别名
```javascript
import * as Person from "./es123.js"
console.log(Person.name);
```

export和import可以结合使用，一些第三方这样做，将其他js文件统一到index.js文件中
```javascript
// 第一种
import { formatDate, formatDate } from "./format";

// 第二种 单个导入
export { formatCount,formatDate } from "./format.js";

// 第三种 全部的导入
export * from "./format.js"
```

#### import函数
通过import加载一个模块，是不可以在其放到逻辑代码中的，这是因为ES Module在被JS引擎解析时，就必须知道它的依赖关系。由于这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况。

如果根据不懂的条件，需要动态来选择加载模块的路径，可以使用` import()` 函数来动态加载,import函数返回一个 Promise，可以通过 then 获取结果
```javascript
let flag = true
if (flag) {
    import("./utils/index.js").then( aaa => {
        console.log(aaa);
    })
}
```

在导入模块时，由于导入的模块使用了不同的导出方式。当一个模块使用了默认导出时，不需要使用大括号；当一个模块使用了命名导出时，需要使用大括号。
```javascript
import { createApp } from "vue"
import  app  from "./vueDemo/app.vue"
```

app.vue的导出方式是默认导出，默认导出`export`时可以不需要指定名字,在导入时不需要使用 {}，并且可以自己来指定名字
```javascript
export default{
    data(){
        return {
            title: "Vue标题"
        }
    }
}
```


##### import meta
import.meta 是一个给JavaScript模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的URL。在ES11（ES2020）中新增的特性。