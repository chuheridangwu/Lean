# UI相关界面

手机型号 | 屏幕尺寸 | 屏幕密度 | 屏幕宽高(pt) | 屏幕分辨率(px) | 倍图 | 屏幕比例
------- | ------- | ------- | ------- | ------- | ------- | -------
4/4s | 3.5inch | 326 ppi | 320*480pt | 640*960px | @2x | 3:2
5/5c/5s/se(第一代) | 4.0inch | 326 ppi | 320*568pt | 640*1136px | @2x | 16:9
6/6s/7/8/se(第二代) | 4.7inch | 326 ppi | 375*667pt | 750*1334px | @2x | 16:9
6+/6s+/7+/8+ | 5.5inch | 401 ppi | 414*736pt | 1242 * 2208px | @3x | 16:9
X/XS/11Pro | 5.8inch | 458 ppi | 375*812pt | 1125* 2436px | @3x | 19.5:9
XR/11 | 6.1inch | 326 ppi | 414*896pt | 828* 1792px | @2x | 19.5:9
Xs Max/11Pro Max | 6.5inch | 458 ppi | 414*896pt | 1242* 2688px | @3x | 19.5:9
iPhone12 mini/13 mini | 5.4inch | 476 ppi | 360*780pt | 1080* 2340px | @3x | 19.5:9
iPhone12/12Pro/13/13Pro/14 | 6.1inch | 460 ppi | 390*844pt | 1170* 2532px | @3x | 19.5:9
iPhone 12 Pro Max /13 Pro Max/14 Plus | 6.7inch | 458 ppi | 428*926pt | 1284* 2778px | @3x | 19.5:9
iPhone14 Pro | 6.1inch | 460 ppi | 393*852pt | 1179* 2556 | @3x | 19.5:9
iPhone14Pro Max | 6.7inch | 460 ppi | 430*932pt | 1290* 2796px | @3x | 19.5:9

APP内如果要支持HTTP网络请求，在`info.plist`文件中添加
```xml
<key>NSAppTransportSecurity</key>
<dict>
<key>NSAllowsArbitraryLoads</key>
<true/>
</dict>
```

## 安全区域
之前状态栏高度：有刘海屏iPhone为44，无刘海屏为20。从 iOS 14 系统开始有刘海屏的iPhone状态栏高度不一定是44了。**安全区域的高度和状态栏的高度不一定是一样的，比如iPhone 14 Pro。**比如：
* `iPhoneXR,iPhone11` 状态栏高度为48，
* `iPhone X，iPhone 11 Pro，iPhone 11 Pro Max，iPhone 12 mini` 状态栏高度44，
* `iPhone 12，iPhone 12 Pro，iPhone 12 Pro Max`，状态栏高度为47

在 `iOS 13.0` 之前，我们可以通过 `UIApplication` 单例中的 `statusBarFrame` 属性获取状态状态栏改度
```swift
UIApplication.shared.statusBarFrame.size.height
```
在 `iOS 13.0` 之后，`statusBarFrame` 属性被废弃⚠️了。API 更换为 `UIStatusBarManager` 类中的 `statusBarFrame` 进行获取
```swift
if #available(iOS 13.0, *) {
        let s = UIApplication.shared.windows.first?.windowScene?.statusBarManager?.statusBarFrame.height
    }
```

* 项目中常用的导航栏高度、状态栏高度
```swift
public let navHeight = statusBarHeight + 44.0  //导航栏高度 44 + 状态栏高度 <安全区域高度跟状态栏高度不一定一致，比如iPhone14 Pro>
//MARK: 状态栏高度
var statusBarHeight: CGFloat {
    get {
        var statusHeight: CGFloat = UIApplication.shared.statusBarFrame.height
        if #available(iOS 13.0, *) {
            guard let scene = UIApplication.shared.windows.first?.windowScene else { return 0 }
            statusHeight = scene.statusBarManager?.statusBarFrame.height ?? 0
        }
        return statusHeight
    }
}
//MARK: 安全区域高度
var safeAreaTop: CGFloat {
    get {
        if #available(iOS 13.0, *) {
            let scene = UIApplication.shared.connectedScenes.first
            guard let windowScene = scene as? UIWindowScene else { return 0 }
            guard let window = windowScene.windows.first else { return 0 }
            return window.safeAreaInsets.top
        } else if #available(iOS 11.0, *) {
            guard let window = UIApplication.shared.windows.first else { return 0 }
            return window.safeAreaInsets.top
        }
        return 0;
    }
}
//MARK: 安全区域底部高度
var safeAreaBottom: CGFloat {
    get {
        if #available(iOS 13.0, *) {
            let scene = UIApplication.shared.connectedScenes.first
            guard let windowScene = scene as? UIWindowScene else { return 0 }
            guard let window = windowScene.windows.first else { return 0 }
            return window.safeAreaInsets.bottom
        } else if #available(iOS 11.0, *) {
            guard let window = UIApplication.shared.windows.first else { return 0 }
            return window.safeAreaInsets.bottom
        }
        return 0;
    }
}
```

* 状态栏高度宏定义
```objc
#define statusHeight \
({CGFloat statusBarHeight = 0.0;\
if (@available(iOS 13.0, *)) {\
statusBarHeight = [UIApplication sharedApplication].windows.firstObject.windowScene.statusBarManager.statusBarFrame.size.height;\
} else { \
statusBarHeight = [UIApplication sharedApplication].statusBarFrame.size.height;\
}\
(statusBarHeight);\
})
```

## UIView
* Runloop渲染的过程
```swift
    /// Render Loop 过程
    /// 过程一：更新约束
    func updateConstraints();
    func setNeedsUpdateConstraints();
    func updateConstraintsIfNeeded();

    /// 过程二：Layout 调整
    func layoutSubviews();
    func setNeedsLayout();
    func layoutIfNeeded();

    /// 过程三：渲染与展示
    func draw(_:);
    func setNeedsDisplay();
```
* 设置背景渐变色
```swift
    func setGradientBackgroundColor(_ colors: [CGColor], axis: NSLayoutConstraint.Axis = .horizontal, locations: [NSNumber] = [0.0, 1.0], cornerRadius: CGFloat = 0.0) -> Void {
        let startPoint = CGPoint.init(x: 0.0, y: 0.0)
        var endPoint = CGPoint.init(x: 1.0, y: 0.0)
        if axis == .vertical {
            endPoint = CGPoint.init(x: 0.0, y: 1.0)
        }
        
        let gradientLayer = CAGradientLayer.init()
        gradientLayer.frame = bounds
        gradientLayer.startPoint = startPoint
        gradientLayer.endPoint = endPoint
        gradientLayer.locations = locations
        gradientLayer.colors = colors
        gradientLayer.cornerRadius = cornerRadius
        
        layer.addSublayer(gradientLayer)
    }
```
* 圆角 + 阴影
```swift
    func setShadow(radius: CGFloat = 8 ,_ shadowColor: UIColor = UIColor(r:128, g: 128, b: 128,a: 1),_ shadowOffset: CGSize = .zero, _ shadowRadius: CGFloat = 3,_  shadowOpacity: Float = 0.3) {
        self.layer.cornerRadius = radius
        self.layer.shadowColor = shadowColor.cgColor //阴影颜色
        self.layer.shadowOffset = shadowOffset //阴影的大小,shadow 在 X 和 Y 轴 上延伸的方向，width往右 height往下是正
        self.layer.shadowRadius = shadowRadius //阴影的扩散范围，相当于blur radius，也是shadow的渐变距离，从外围开始，往里渐变shadowRadius距离
        self.layer.shadowOpacity = shadowOpacity //阴影的不透明度
    }
```
* 模糊 毛玻璃效果
```swift
    func setEffect() -> UIView{
        let blurEffect = UIBlurEffect(style: UIBlurEffect.Style.dark)
        let blurView = UIVisualEffectView(effect: blurEffect)
        blurView.frame.size = CGSize(width: self.frame.size.width, height: self.frame.size.height)
        blurView.layer.masksToBounds = true
        return blurView
    }
```


## UILabel
* 设置文字渐变自定义一个UILabel，重写`drawRect`方法,在当前方法中使用渐变
```objc
    - (void)drawRect:(CGRect)rect{
        [super drawRect:rect];
        
        CGContextRef context = UIGraphicsGetCurrentContext();
        // 获取文字mask
        [self.text drawInRect:self.bounds withAttributes:@{NSFontAttributeName : self.font}];
        CGImageRef textMask = CGBitmapContextCreateImage(context);

        // 清空画布
        CGContextClearRect(context, rect);

        // 设置蒙层
        CGContextTranslateCTM(context, 0.0, self.bounds.size.height);
        CGContextScaleCTM(context, 1.0, -1.0);
        CGContextClipToMask(context, rect, textMask);

        // 绘制渐变
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        // 渐变的距离 0 - 1
        CGFloat locations[] = {0, 1};
        // 颜色矩阵
        CGFloat colors[] = {1.0,0.0,0.0,1.0,
                            0.0,1.0,0.0,1.0};
        CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, colors, locations, 2);
        CGPoint start = CGPointMake(0, 0);
        CGPoint end = CGPointMake(0, self.bounds.size.height);
        CGContextDrawLinearGradient(context, gradient, start, end, kCGGradientDrawsBeforeStartLocation);

        // 释放
        CGColorSpaceRelease(colorSpace);
        CGGradientRelease(gradient);
        CGImageRelease(textMask);
    }
```

* 字体粗细
```swift
titleLabel.font = UIFont.systemFont(ofSize: 17.0)
titleLabel.font = UIFont.systemFont(ofSize: 17.0, weight: .heavy)
// 字体从细到粗
public static let ultraLight: UIFont.Weight
public static let thin: UIFont.Weight
public static let light: UIFont.Weight
public static let regular: UIFont.Weight
...
```

## UITableView
* UITableView设置Cell的一些技巧
```objc
// 取消选中状态
cell.selectionStyle=UITableViewCellAccessoryNone; 
// 取消指定的cell分割线
cell.separatorInset = UIEdgeInsetsMake(0, 0, 0, 120); 
// 默认带系统箭头
cell.accessoryType = .disclosureIndicator 
// 取消所有cell的分割线
tableview.separatorStyle = UITableViewCellSeparatorStyleNone; 
```
* UITableView 分区设置圆角
```swift
        func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        guard let cell = cell as? TableViewCell else { return }
        let radius: CGFloat = 10  //圆角
        let rows = tableView.numberOfRows(inSection: indexPath.section) // 分区有多少个cell
        let row = indexPath.row
        // 如果是纯代码或者xib不想在awakeFromNib里面设置widget的具体大小,这里需要搞成你需要设置的size
        let rectBounds = cell.widget.bounds;
        
        // 分区只有一行时默认设置四个圆角角
        var maskPath:UIBezierPath = UIBezierPath.init(roundedRect: rectBounds, cornerRadius: radius)
        
        if  rows > 1{
            if row == 0{ // 当前section不止1行，设置第一行cell的左上角和右上角
                
                maskPath = UIBezierPath.init(roundedRect: rectBounds, byRoundingCorners: [.topLeft,.topRight],cornerRadii: CGSize(width: radius, height: radius))
                
            }else if row == rows-1{ // 设置最后一行cell的的左下角和右下角
                
                maskPath = UIBezierPath.init(roundedRect: rectBounds, byRoundingCorners: [.bottomLeft,.bottomRight], cornerRadii: CGSize(width: radius, height: radius))
                
            }else{ // 当前cell为中间行,不设置圆角
                maskPath = UIBezierPath.init(roundedRect: rectBounds, cornerRadius: .zero)
            }
        }
        
        let maskLayer = CAShapeLayer.init()
        maskLayer.frame = rectBounds
        maskLayer.path = maskPath.cgPath
        cell.widget.layer.mask = maskLayer
    }
```
注意如果cell是由xib进行创建的,需要在`awakeFromNib`方法中设置圆角控件的具体大小
```swift
    override func awakeFromNib() {
        super.awakeFromNib()
        let size = UIScreen.main.bounds.size
        widget.frame = CGRect(x: 10, y: 0, width:size.width - 20 , height: 50)
    }
```
>如果是纯代码创建cell，在`init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) `方法中获取到的cell宽度也是固定的320，高度是44，需要在`willDisplay`方法中设置`rectBounds`的固定大小


## UITextField
* UITextfield常用属性
```swift
    let textField = UITextField()
    // 设置 样式 (.none 无边框  .line 直线边框  .roundedRect 圆角矩形边框  .bezel 边线+阴影)
    textField.borderStyle = UITextBorderStyle.roundedRect
    // 设置 提示字
    textField.placeholder = "我是 UITextfield"       
    // 设置 文字超出文本框时自适应大小
    textField.adjustsFontSizeToFitWidth = true
    // 设置 最小可缩小的字号
    textField.minimumFontSize = 13
    // 设置 清理按钮 (.never 从不出现 .whileEditing 编辑时出现 .unlessEditing 编辑时不出现 编辑完后出现 .always 一直出现)
    textField.clearButtonMode = UITextFieldViewMode.whileEditing
    //  设置 键盘样式
    textField.keyboardType = UIKeyboardType.default
    //  监听文字变化
    textField.addTarget(self, action: #selector(valueChange), for: .editingChanged)
```
* UITextfield常用代理
```swift
    // 输入框询问是否可以编辑 true 可以编辑  false 不能编辑
    func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
        print("我要开始编辑了...")
        return true
    }
    // 该方法代表输入框已经可以开始编辑  进入编辑状态
    func textFieldDidBeginEditing(_ textField: UITextField) {
        print("我正在编辑状态中...")  
    }
    // 输入框将要将要结束编辑
    func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
        print("我即将编辑结束...")
        return true
    }
    // 输入框结束编辑状态
    func textFieldDidEndEditing(_ textField: UITextField) {
        print("我已经结束编辑状态...")
    } 
    // 文本框是否可以清除内容
    func textFieldShouldClear(_ textField: UITextField) -> Bool {
        return true
    }
    // 输入框按下键盘 return 收回键盘
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return true
    }                                                                         // 该方法当文本框内容出现变化时 及时获取文本最新内容
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        return true
    }
```

* 禁止粘贴
UITextField禁止粘贴，自定义UITextField重写`-(BOOL)canPerformAction:(SEL)action withSender:(id)sender`方法。
```swift
class CustomTextField: UITextField {
    override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
        if action == #selector(paste(_:)){
            return false
        }
//       也可以这样比较方法 
//        if action == #selector(UIResponderStandardEditActions.paste(_:)){
//            return false
//        }
        return true
    }
}
```

其他一些可以禁止的方法:
```swift
cut: // 剪切
copy: // 拷贝
select: // 选择
selectAll: // 全选
paste: // 粘贴
delete: // 删除
_promptForReplace: // Replace...
_transliterateChinese: // 简<=>繁
_showTextStyleOptions: // B/<u>U</u>
_define: // Define
_addShortcut: // Learn...
_accessibilitySpeak: // Speak
_accessibilitySpeakLanguageSelection: // Speak...
_accessibilityPauseSpeaking: // Pause
_share: // 共享...
makeTextWritingDirectionRightToLeft: // 往右缩进
makeTextWritingDirectionLeftToRight: // 往左缩进
```

## WKWebView
WKWebView需要导入`import Webkit`框架

* 初始化WKWebView
```swift
webView = WKWebView(frame: view.bounds)
webView.scrollView.contentInsetAdjustmentBehavior = .never
webView.isOpaque = false
webView.backgroundColor = UIColor.clear
webView.navigationDelegate = self
webView.uiDelegate = self    //监听通过JS调用警告框
webView.scrollView.showsVerticalScrollIndicator = false
webView.scrollView.bounces = false  //禁止弹回
view.addSubview(webView)
```
* WKNavigationDelegate代理方法
```swift
extension ViewController: WKNavigationDelegate {
    //页面加载完成之后调用
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {

        weak var weakSelf = self
        webView.evaluateJavaScript("Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight)") { (result, error) in
            if result == nil { return }
            
            let height = "\(result!)".floatValue()
            weakSelf?.webView.frame.size.height = CGFloat(height)
        }
    }
}
```

禁止长按弹出提示框需要跟webView进行交互
```swift
webView.evaluateJavaScript("document.documentElement.style.webkitTouchCallout='none';",completionHandler: nil)
```

* 获取WkWebView真实高度
通过KVO监听scrollView的的`contentSize`属性,当网页加载完成后，通过获取的宽高比,获取真实高度。
```swift
override func viewDidLoad() {
    super.viewDidLoad()
    webView.addObserver(self, forKeyPath: "scrollView.contentSize" , options: [.new, .old], context: nil)
}
override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
    // 通过KVO监听
    let newValue = change?[NSKeyValueChangeKey.newKey] as? CGSize ?? .zero
    print(newValue)
    
}
extension ViewController: WKNavigationDelegate{
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        // 获取宽度
        webView.evaluateJavaScript("document.body.scrollWidth") { body, error in
            guard let v = body as? CGFloat else { return }
            let ratio =   v / UIScreen.main.bounds.size.width
            // 获取高度
            webView.evaluateJavaScript("document.body.scrollHeight") { [weak self] body1, error1 in
                guard let v1 = body1 as? CGFloat else { return }
                self?.webH.constant = v1 * ratio
            }
        }
    }
}
```

## UITabBar
```swift
// 通过KVO的方式使用自定义TabBar
class TabBarController: UITabBarController {
    override func viewDidLoad() {
        super.viewDidLoad()
        setValue(TabBar(), forKeyPath: "tabBar")
    }
}
class TabBar: UITabBar {
    override func layoutSubviews() {
        super.layoutSubviews()
        for button in subviews where button is UIControl{
            var frame  = button.frame
            frame.origin.y = -2
            button.frame = frame
        }
    }
}
```

## 序列化和反序列化
Swift4 中引入了 `Codable` 协议，我们只需要让需要序列化的对象符合 `Codable` 协议即可，不用再写任何其他的代码
```swift
class Person: NSObject, HandyJSON,Codable{
    var age: String?
    var name: String?
    required override init() {}
}
class MUserMode: NSObject, HandyJSON,Codable {
    var token: String?
    var account: String?//注册时填写的手机号
    var list: [String]?//用户id
    var person: Person?
    required override init() {}
    
    static func filePath () -> String?{
        
        if let basePath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first{
            let className = String(describing: type(of: self))
            return basePath.appending("/\(className)")
        }
        return nil
    }
    
    func archived(){
        let selfClass = type(of: self)
        guard let filePath = selfClass.filePath() else { return }
        let fileUrl = URL(fileURLWithPath: filePath)
        let data = try? JSONEncoder().encode(self)
        try? data?.write(to: fileUrl, options: .atomic)
    }
    
    static func unarchived() -> Self?{
        guard let filePath = self.filePath() else {  return nil }
        let fileUrl = URL(fileURLWithPath: filePath)
        guard let data = try? Data.init(contentsOf: fileUrl) else { return nil }
        let decodedData = try? JSONDecoder().decode(self, from: data)
        return decodedData
    }
}
```
在项目中使用
```swift
override func viewDidLoad() {
    super.viewDidLoad()
    let dict : Dictionary<String,Any> = ["token":"用户ID","account":"头像地址","list":["1","2","3"],"person":["age":"10","name":"name123"]]

    let mode = MUserMode.deserialize(from: dict)
    mode?.archived()
    
    let m = MUserMode.unarchived()
```

## UIAlertController
* 使用 UIAlertController
```swift
    let alert = UIAlertController.init(title: "标题", message: "消息", preferredStyle: .alert)
    let cancel = UIAlertAction(title: "取消", style: UIAlertAction.Style.cancel)
    let ok = UIAlertAction(title: "确定", style: UIAlertAction.Style.default)

    // 通过 KVC 改变字体颜色
    ok.setValue(UIColor.black, forKey: "titleTextColor")

    // 添加TextField
    alert.addTextField { textField in  }
    
    alert.addAction(cancel)
    alert.addAction(ok)
    present(alert, animated: true)
```
* 改变标题、及提示信息的字体
```swift
    // 改变标题文字颜色
    let titleAttr = NSAttributedString.init(string: "标题",attributes: [
        NSAttributedString.Key.font: UIFont.systemFont(ofSize: 20),
        NSAttributedString.Key.foregroundColor: UIColor.red
    ])
    alert.setValue(titleAttr, forKey: "attributedTitle")

    // 改变消息文字颜色
    let msgAttr = NSAttributedString.init(string: "测试可变消息",attributes: [.font: UIFont.systemFont(ofSize: 18),.foregroundColor: UIColor.blue ])
    alert.setValue(msgAttr, forKey: "attributedMessage")
```
* iPad调用UIAlertController,需要在`present`方法前添加以下代码进行适配
```swift
    if UIDevice.current.userInterfaceIdiom == .pad{
        let pop = alert.popoverPresentationController
        pop?.sourceView = view
        pop?.permittedArrowDirections = .up
        pop?.sourceRect = view.bounds
    }
    present(alert, animated: true)
```