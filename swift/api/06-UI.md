# UI相关界面

手机型号 | 屏幕尺寸 | 屏幕密度 | 屏幕宽高(pt) | 屏幕分辨率(px) | 倍图 | 屏幕比例
------- | ------- | ------- | ------- | ------- | ------- | -------
4/4s | 3.5inch | 326 ppi | 320*480pt | 640*960px | @2x | 3:2
5/5c/5s/se(第一代) | 4.0inch | 326 ppi | 320*568pt | 640*1136px | @2x | 16:9
6/6s/7/8/se(第二代) | 4.7inch | 326 ppi | 375*667pt | 750*1334px | @2x | 16:9
6+/6s+/7+/8+ | 5.5inch | 401 ppi | 414*736pt | 1242 * 2208px | @3x | 16:9
X/XS/11Pro | 5.8inch | 458 ppi | 375*812pt | 1125* 2436px | @3x | 19.5:9
XR/11 | 6.1inch | 326 ppi | 414*896pt | 828* 1792px | @2x | 19.5:9
Xs Max/11Pro Max | 6.5inch | 458 ppi | 414*896pt | 1242* 2688px | @3x | 19.5:9
iPhone12 mini/13 mini | 5.4inch | 476 ppi | 360*780pt | 1080* 2340px | @3x | 19.5:9
iPhone12/12Pro/13/13Pro/14 | 6.1inch | 460 ppi | 390*844pt | 1170* 2532px | @3x | 19.5:9
iPhone 12 Pro Max /13 Pro Max/14 Plus | 6.7inch | 458 ppi | 428*926pt | 1284* 2778px | @3x | 19.5:9
iPhone14 Pro | 6.1inch | 460 ppi | 393*852pt | 1179* 2556 | @3x | 19.5:9
iPhone14Pro Max | 6.7inch | 460 ppi | 430*932pt | 1290* 2796px | @3x | 19.5:9

APP内如果要支持HTTP网络请求，在`info.plist`文件中添加
```xml
<key>NSAppTransportSecurity</key>
<dict>
<key>NSAllowsArbitraryLoads</key>
<true/>
</dict>
```

## 安全区域
之前状态栏高度：有刘海屏iPhone为44，无刘海屏为20。从 iOS 14 系统开始有刘海屏的iPhone状态栏高度不一定是44了。**安全区域的高度和状态栏的高度不一定是一样的，比如iPhone 14 Pro。**比如：
* `iPhoneXR,iPhone11` 状态栏高度为48，
* `iPhone X，iPhone 11 Pro，iPhone 11 Pro Max，iPhone 12 mini` 状态栏高度44，
* `iPhone 12，iPhone 12 Pro，iPhone 12 Pro Max`，状态栏高度为47

在 `iOS 13.0` 之前，我们可以通过 `UIApplication` 单例中的 `statusBarFrame` 属性获取状态状态栏改度
```swift
UIApplication.shared.statusBarFrame.size.height
```
在 `iOS 13.0` 之后，`statusBarFrame` 属性被废弃⚠️了。API 更换为 `UIStatusBarManager` 类中的 `statusBarFrame` 进行获取
```swift
if #available(iOS 13.0, *) {
        let s = UIApplication.shared.windows.first?.windowScene?.statusBarManager?.statusBarFrame.height
    }
```

* 项目中常用的导航栏高度、状态栏高度
```swift
public let navHeight = statusBarHeight + 44.0  //导航栏高度 44 + 状态栏高度 <安全区域高度跟状态栏高度不一定一致，比如iPhone14 Pro>
//MARK: 状态栏高度
var statusBarHeight: CGFloat {
    get {
        var statusHeight: CGFloat = UIApplication.shared.statusBarFrame.height
        if #available(iOS 13.0, *) {
            guard let scene = UIApplication.shared.windows.first?.windowScene else { return 0 }
            statusHeight = scene.statusBarManager?.statusBarFrame.height ?? 0
        }
        return statusHeight
    }
}
//MARK: 安全区域高度
var safeAreaTop: CGFloat {
    get {
        if #available(iOS 13.0, *) {
            let scene = UIApplication.shared.connectedScenes.first
            guard let windowScene = scene as? UIWindowScene else { return 0 }
            guard let window = windowScene.windows.first else { return 0 }
            return window.safeAreaInsets.top
        } else if #available(iOS 11.0, *) {
            guard let window = UIApplication.shared.windows.first else { return 0 }
            return window.safeAreaInsets.top
        }
        return 0;
    }
}
//MARK: 安全区域底部高度
var safeAreaBottom: CGFloat {
    get {
        if #available(iOS 13.0, *) {
            let scene = UIApplication.shared.connectedScenes.first
            guard let windowScene = scene as? UIWindowScene else { return 0 }
            guard let window = windowScene.windows.first else { return 0 }
            return window.safeAreaInsets.bottom
        } else if #available(iOS 11.0, *) {
            guard let window = UIApplication.shared.windows.first else { return 0 }
            return window.safeAreaInsets.bottom
        }
        return 0;
    }
}
```

* 状态栏高度宏定义
```objc
#define statusHeight \
({CGFloat statusBarHeight = 0.0;\
if (@available(iOS 13.0, *)) {\
statusBarHeight = [UIApplication sharedApplication].windows.firstObject.windowScene.statusBarManager.statusBarFrame.size.height;\
} else { \
statusBarHeight = [UIApplication sharedApplication].statusBarFrame.size.height;\
}\
(statusBarHeight);\
})
```

## UILabel的文字渐变
自定义一个UILabel，重写`drawRect`方法,在当前方法中使用渐变
```objc
- (void)drawRect:(CGRect)rect{
    [super drawRect:rect];
    
    CGContextRef context = UIGraphicsGetCurrentContext();
    // 获取文字mask
    [self.text drawInRect:self.bounds withAttributes:@{NSFontAttributeName : self.font}];
    CGImageRef textMask = CGBitmapContextCreateImage(context);

    // 清空画布
    CGContextClearRect(context, rect);

    // 设置蒙层
    CGContextTranslateCTM(context, 0.0, self.bounds.size.height);
    CGContextScaleCTM(context, 1.0, -1.0);
    CGContextClipToMask(context, rect, textMask);

    // 绘制渐变
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    // 渐变的距离 0 - 1
    CGFloat locations[] = {0, 1};
    // 颜色矩阵
    CGFloat colors[] = {1.0,0.0,0.0,1.0,
                        0.0,1.0,0.0,1.0};
    CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, colors, locations, 2);
    CGPoint start = CGPointMake(0, 0);
    CGPoint end = CGPointMake(0, self.bounds.size.height);
    CGContextDrawLinearGradient(context, gradient, start, end, kCGGradientDrawsBeforeStartLocation);

    // 释放
    CGColorSpaceRelease(colorSpace);
    CGGradientRelease(gradient);
    CGImageRelease(textMask);
}
```

* 字体粗细
```swift
titleLabel.font = UIFont.systemFont(ofSize: 17.0)
titleLabel.font = UIFont.systemFont(ofSize: 17.0, weight: .heavy)
// 字体从细到粗
public static let ultraLight: UIFont.Weight
public static let thin: UIFont.Weight
public static let light: UIFont.Weight
public static let regular: UIFont.Weight
public static let medium: UIFont.Weight
public static let semibold: UIFont.Weight
public static let bold: UIFont.Weight
public static let heavy: UIFont.Weight
public static let black: UIFont.Weight
```

## UITableView
UITableView的一些技巧
```objc
// 取消选中状态
cell.selectionStyle=UITableViewCellAccessoryNone; 
// 取消指定的cell分割线
cell.separatorInset = UIEdgeInsetsMake(0, 0, 0, 120); 
// 默认带系统箭头
cell.accessoryType = .disclosureIndicator 
// 取消所有cell的分割线
tableview.separatorStyle = UITableViewCellSeparatorStyleNone; 
```

## UITextField
* UITextfield常用属性
```swift
let textField = UITextField()
// 设置 样式 (.none 无边框  .line 直线边框  .roundedRect 圆角矩形边框  .bezel 边线+阴影)
textField.borderStyle = UITextBorderStyle.roundedRect
// 设置 提示字
textField.placeholder = "我是 UITextfield"       
// 设置 文字超出文本框时自适应大小
textField.adjustsFontSizeToFitWidth = true
// 设置 最小可缩小的字号
textField.minimumFontSize = 13
// 设置 清理按钮 (.never 从不出现 .whileEditing 编辑时出现 .unlessEditing 编辑时不出现 编辑完后出现 .always 一直出现)
textField.clearButtonMode = UITextFieldViewMode.whileEditing
//  设置 键盘样式
textField.keyboardType = UIKeyboardType.default
```
* UITextfield常用代理
```swift
// 输入框询问是否可以编辑 true 可以编辑  false 不能编辑
func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
    print("我要开始编辑了...")
    return true
}
// 该方法代表输入框已经可以开始编辑  进入编辑状态
func textFieldDidBeginEditing(_ textField: UITextField) {
    print("我正在编辑状态中...")  
}
// 输入框将要将要结束编辑
func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
    print("我即将编辑结束...")
    return true
}
// 输入框结束编辑状态
func textFieldDidEndEditing(_ textField: UITextField) {
    print("我已经结束编辑状态...")
} 
// 文本框是否可以清除内容
func textFieldShouldClear(_ textField: UITextField) -> Bool {
    return true
}
// 输入框按下键盘 return 收回键盘
func textFieldShouldReturn(_ textField: UITextField) -> Bool {
    textField.resignFirstResponder()
    return true
}                                                                         // 该方法当文本框内容出现变化时 及时获取文本最新内容
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
    return true
}
```

## WKWebView
WKWebView需要导入`import Webkit`框架

* 初始化WKWebView
```swift
webView = WKWebView(frame: view.bounds)
webView.scrollView.contentInsetAdjustmentBehavior = .never
webView.isOpaque = false
webView.backgroundColor = UIColor.clear
webView.navigationDelegate = self
webView.uiDelegate = self    //监听通过JS调用警告框
webView.scrollView.showsVerticalScrollIndicator = false
webView.scrollView.bounces = false  //禁止弹回
view.addSubview(webView)
```
* WKNavigationDelegate代理方法
```swift
extension ViewController: WKNavigationDelegate {
    //页面加载完成之后调用
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {

        weak var weakSelf = self
        webView.evaluateJavaScript("Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight)") { (result, error) in
            if result == nil { return }
            
            let height = "\(result!)".floatValue()
            weakSelf?.webView.frame.size.height = CGFloat(height)
        }
    }
}
```

禁止长按弹出提示框需要跟webView进行交互
```swift
webView.evaluateJavaScript("document.documentElement.style.webkitTouchCallout='none';",completionHandler: nil)
```

* 获取WkWebView真实高度
通过KVO监听scrollView的的`contentSize`属性,当网页加载完成后，通过获取的宽高比,获取真实高度。
```swift
override func viewDidLoad() {
    super.viewDidLoad()
    webView.addObserver(self, forKeyPath: "scrollView.contentSize" , options: [.new, .old], context: nil)
}
override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
    // 通过KVO监听
    let newValue = change?[NSKeyValueChangeKey.newKey] as? CGSize ?? .zero
    print(newValue)
    
}
extension ViewController: WKNavigationDelegate{
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        // 获取宽度
        webView.evaluateJavaScript("document.body.scrollWidth") { body, error in
            guard let v = body as? CGFloat else { return }
            let ratio =   v / UIScreen.main.bounds.size.width
            // 获取高度
            webView.evaluateJavaScript("document.body.scrollHeight") { [weak self] body1, error1 in
                guard let v1 = body1 as? CGFloat else { return }
                self?.webH.constant = v1 * ratio
            }
        }
    }
}
```

## UITabBar
```swift
// 通过KVO的方式使用自定义TabBar
class TabBarController: UITabBarController {
    override func viewDidLoad() {
        super.viewDidLoad()
        setValue(TabBar(), forKeyPath: "tabBar")
    }
}
class TabBar: UITabBar {
    override func layoutSubviews() {
        super.layoutSubviews()
        for button in subviews where button is UIControl{
            var frame  = button.frame
            frame.origin.y = -2
            button.frame = frame
        }
    }
}
```

## 序列化和反序列化
Swift4 中引入了 `Codable` 协议，我们只需要让需要序列化的对象符合 `Codable` 协议即可，不用再写任何其他的代码
```swift
class Person: NSObject, HandyJSON,Codable{
    var age: String?
    var name: String?
    required override init() {}
}
class MUserMode: NSObject, HandyJSON,Codable {
    var token: String?
    var account: String?//注册时填写的手机号
    var list: [String]?//用户id
    var person: Person?
    required override init() {}
    
    static func filePath () -> String?{
        
        if let basePath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first{
            let className = String(describing: type(of: self))
            return basePath.appending("/\(className)")
        }
        return nil
    }
    
    func archived(){
        let selfClass = type(of: self)
        guard let filePath = selfClass.filePath() else { return }
        let fileUrl = URL(fileURLWithPath: filePath)
        let data = try? JSONEncoder().encode(self)
        try? data?.write(to: fileUrl, options: .atomic)
    }
    
    static func unarchived() -> Self?{
        guard let filePath = self.filePath() else {  return nil }
        let fileUrl = URL(fileURLWithPath: filePath)
        guard let data = try? Data.init(contentsOf: fileUrl) else { return nil }
        let decodedData = try? JSONDecoder().decode(self, from: data)
        return decodedData
    }
}
```
在项目中使用
```swift
override func viewDidLoad() {
    super.viewDidLoad()
    let dict : Dictionary<String,Any> = ["token":"用户ID","account":"头像地址","list":["1","2","3"],"person":["age":"10","name":"name123"]]

    let mode = MUserMode.deserialize(from: dict)
    mode?.archived()
    
    let m = MUserMode.unarchived()
```