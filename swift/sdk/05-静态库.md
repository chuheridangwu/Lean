# 静态库

## Build Configuration
如果做多环境配置，除了多个 Target 之外还可以使用多个Scheme的方式，配置多个`Configuration Settings File` 文件。

Xcode编译默认有 Release 和 Debug 两种模式，可以自己添加一种编译模式，通过在Xcode中添加自定义配置达到多环境配置。比如配置不同的URL：
1. 添加 Beta  Configuration

![](../imgs/sdk/ios_sdk_1.png ':size=600')

2. 在 Xcode 中添加自定义配置

![](../imgs/sdk/ios_sdk_2.png ':size=600')

3. 在 info.plist 文件中使用变量

![](../imgs/sdk/ios_sdk_3.png ':size=600')

4. 通过切换编译模式可以获取不同的值

![](../imgs/sdk/ios_sdk_4.png ':size=600')

当我们使用 Cocoapods 导入第三方的时候，Cocoapods 会给我们创建2个配置文件。

![](../imgs/sdk/ios_sdk_5.png ':size=600')

对应的就是Xcode中的自定义宏。

![](../imgs/sdk/ios_sdk_6.png ':size=600')

也就是说`Xcode -> Target -> Build Settings`里的信息，我们可以直接通过文件进行配置。这样的话我们就可以通过自定义 Configuration 文件来达到我们刚才的目的
1. 首先创建两个 `Configuration Settings File` 文件，一个 Debug 模式，一个 Release 模式。文件内写入:
```
HTTP_URL = "www.debug.com"
```
2. 在对应的模式下使用对应的 Configuration 文件

![](../imgs/sdk/ios_sdk_7.png ':size=600')
3. 在 `info.plist` 文件中使用变量,通过切换编译模式可以获取不同的值

## Configuration 文件

Configuration 文件中还可以配置其他的Xcode选项，比如常用的`Other Linker Flags`可以通过文件进行配置：
```xml
// key-value
OTHER_LDFLAGS = -framework "AFNetworking"
```

`OTHER_LDFLAGS` 是`Other Linker Flags`的缩写，通过[xcodebuildsettings](https://xcodebuildsettings.com/)这个网站可以找到Xcode配置中的缩写，比如`System Header Search Paths`：
![](../imgs/sdk/ios_sdk_8.png ':size=600')

> 注意有部分变量不能通过`xcconfig`配置到`Build Settings`中，例如`PRODUCT_BUNDLE_IDENTIFIER`,配置之后不起作用

## 导入其他的 `Configuration`文件
如果有多个`Configuration`文件,在Xcode中配置时只能配置一个，可以选择在一个`Configuration`文件中导入其他的`Configuration`文件。比如
```
#include "pod/Target Support Files/Pods-SDemo/Pods-SDemo.debug.xcconfig"
```
如果两个文件中有同样的 key 比如`OTHER_LDFLAGS` ,后面导入的文件会重置之前文件的变量。如果防止这种现象，使用`$(inherited)`。它会将你导入的其他文件的 value 传递过来，类似继承
```xcconfig
#include "pod/Target Support Files/Pods-SDemo/Pods-SDemo.debug.xcconfig"

OTHER_LDFLAGS = $(inherited) -framework "AVFoundation"
```

`Configuration`文件还可以指定的模式，比如
```swift
OTHER_LDFLAGS[config=Debug][sdk=iphonesimulator*][arch=x86_64] = $(inherited) -framework "AVFoundation"
```
在Xcode11.4之后，可以使用`default`指定变量为空时的默认值
```
$(BUILD_SETTING_NAME:default=value)
```

##  -Xlinker

-Xlinker 将后续的参数传递链接器ld

## strip
strip具体就是从特定文件中剥掉一些符号信息和调试信息。定义 main.c 文件
```c
#include <stdio.h>
  
int add(int x, int y)
{
    return x + y;
}
  
int aaa;
int bbb = 1;
char szTest[] = "good";
  
int main()
{
    int ccc = 2;
    return 0;
}
```
gcc指令生成编译文件,查看编译的结果
```shell
xxxxxMacBook-Pro-2 Desktop % gcc main.c
xxxxxMacBook-Pro-2 Desktop % file a.out
a.out: Mach-O 64-bit executable arm64
xxxxxMacBook-Pro-2 Desktop % nm a.out   
0000000100000000 T __mh_execute_header
000000010000400c S _aaa
0000000100003f7c T _add
0000000100004000 D _bbb
0000000100003f9c T _main
0000000100004004 D _szTest
xxxxxMacBook-Pro-2 Desktop % ls -l a.out
-rwxr-xr-x  1 mlive  staff  33490 Nov  9 15:11 a.out
```
通过`ls -l` 命令可知， a.out的大小是 33490 个字节；

通过`file`命令可知， a.out是可执行文件， 且是`not stripped`, 也就是说没有脱衣服。

通过`nm`命令， 可以读出 a.out 中的符号信息。使用 strip 剥掉一些符号信息
```
xxxxxMacBook-Pro-2 Desktop % strip a.out
xxxxxMacBook-Pro-2 Desktop % ls -l a.out
-rwxr-xr-x  1 mlive  staff  33384 Nov  9 15:14 a.out
xxxxxMacBook-Pro-2 Desktop % nm a.out
0000000100000000 T __mh_execute_header
```
通过`ls -l` 命令可知， a.out的大小是 33384 个字节

>strip不仅仅可以针对可执行文件， 还能针对目标文件和动态库等。

## 常用的库文件格式
.a : 静态库
.dylib ： 动态库
.framework ：有静态库，也有动态库，可以静动结合
.xcframework ：2018年苹果新出的针对不同架构`x86/armv7/arm64`的库文件格式

## 静态库文件格式
静态库文件是所有.o文件的合集，ar 指令可以查看和修改静态库文件。比如使用`ar -t libAFNetworking.a`查看.a文件,查看出来就是所有.o文件的合集。
```
AFAutoPurgingImageCache.o
AFHTTPSessionManager.o
AFImageDownloader.o
AFNetworkActivityIndicatorManager.o
AFNetworking-dummy.o
AFNetworkReachabilityManager.o
AFSecurityPolicy.o
AFURLRequestSerialization.o
AFURLResponseSerialization.o
AFURLSessionManager.o
UIActivityIndicatorView+AFNetworking.o
UIButton+AFNetworking.o
UIImageView+AFNetworking.o
UIProgressView+AFNetworking.o
UIRefreshControl+AFNetworking.o
WKWebView+AFNetworking.o
```
## 通过编译查看编译将静态库文件编译到.o文件中
先编译，再链接，先将.m文件编译成.o文件，再将.o文件链接上本地的静态库生成可执行文件。