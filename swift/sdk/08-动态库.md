# 动态库
与静态库相反，动态库在编译时并不会被拷⻉到⽬标程序中，⽬标程序中只会存储指向动态库的引⽤。等到程序运⾏时，动态库才会被真正加载进来。格式有：.framework、.dylib、.tdb。

缺点： 会导致⼀些性能损失。但是可以优化，⽐如延迟绑定(Lazy Binding)技术

静态库是 .o 文件的合集，动态库是 .o 文件链接过后的产物。动态库不能合并。跟静态库一样，先使用一个例子展示一下怎么链接动态库。

一个 test.m 文件,文件中用到了静态库`AFNetworking`,我们使用clang编译器将下面的代码编译成可执行文件。
```objc
#import <Foundation/Foundation.h>
#import <AFNetworking.h>
int main(){
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    NSLog(@"testApp----%@", manager);
    return 0;
}
```

1. 将test.m文件编译成 .o 文件
```
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -I./AFNetworking \
    -c test.m -o test.o
```
2. 将.o文件编译成可执行文件
```
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -L./AFNetworking \
    -lAFNetworking \
    test.o -o test
```
3. 使用`lldb`运行可执行文件,会报找不到动态库的错误，如下图:
   ![](../imgs/sdk/ios_sdk_18.png)
4. 使用  

## 手动编译动态库
还是使用编译静态库的例子,不同的是我们这次需要将 TestExample.m 文件编译成动态库。
1. 将 test.m 编译成 .o 文件
```
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -I./dylib \
    -c test.m -o test.o
```
2. 将 TestExample.m 编译成 .o 文件
```
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -c TestExample.m -o TestExample.o
```
3. 编译静态库
```
    libtool -static -arch_only x86_64 TestExample.o -o libTestExample.a
```

4. 使用 `ld` 编译动态库
```
    ld -dylib -arch x86_64 \
    -macosx_version_min 11.1 \
    -syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -lsystem -framework Foundation \
    -all_load \
    libTestExample.a -o libTestExample
```
>`-all_load`这里是必须要加的，因为默认是`-no_all_load`,会导致类被剥离，找不到类文件。**这里在编译动态库时没有编译动态库的路径,使用`-install_name`参数可以在编译动态库时写入路径**

5. 生成可执行文件
```
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -L./dylib \
    -lTestExample \
    test.o -o test
```
6. 使用`lldb`运行可执行文件,会报找不到动态库的错误，如下图:
    ![](../imgs/sdk/ios_sdk_18.png)
    当 `dyld` 加载一个可执行文件，下图中的 Mach-O 相当于test可执行文件。在可执行文件中的`LC_LOAD_DYLIB`中,保存着动态库的路径`@rpath/AFNetworking.framework/Versions/A/AFNetworking'`。

    **我们知道动态库是运行时加载的，就是dyld通过动态库的路径找到动态库进行加载的。**当dyld通过路径找不到动态库时就会报错。
    ![](../imgs/sdk/ios_sdk_19.png ':size=750')

7. 使用`otool -l test | grep 'DYLIB' -A 3`查看可执行文件中的动态库路径时发现路径不对。
   ![](../imgs/sdk/ios_sdk_20.png ':size=750')
   
   可执行文件是怎么知道动态库的路径呢?动态库在编译的时候，在动态库本身中的一个`LC_ID_DYLIB`是来保存路径。
   
   使用`otool -l libTestExample.dylib | grep "ID" -A 5`查看动态库的路径
    ![](../imgs/sdk/ios_sdk_21.png ':size=750')

8. 使用`install_name_tool id 动态库路径  动态库`修改动态库的路径,修改完成后再使用`otool -l libTestExample.dylib | grep "ID" -A 5`查看动态库的路径已经改变。
9. 重新编译 test 可执行文件，通过 lldb 进行加载测试，完全OK。

## 链接器 ld
如果在编译动态库的时候，直接在编译时将路径写入到动态库就不需要后面那几个步骤。`-install_name`本来就是链接器的参数。

在之前我们修改动态库的路径时使用的是绝对路径，但是在编译动态库时的路径，肯定要使用相对路径，如何解决这个问题，就需要用到`@rpath`

>谁使用动态库，`@rpath`保存的就是谁的路径。`@rpath`可以保存⼀个或多个路径的变量

##### 使用 @rpath
1. 我们继续使用上面的例子，将`libTestExample.dylib`动态库的路径使用`@rpath`修改为相对路径,`libTestExample.dylib` 文件在可执行文件目录下的子目录`dylib`文件夹下。
```shell
    install_name_tool -id @rpath/dylib/libTestExample.dylib  libTestExample.dylib
```
2. `@rpath`的值是从哪里来的呢？**可执行文件中有一个cmd`LC_RPATH`保存着`@rpath`的值。** 当我们使用`otool -l test | grep "RPATH" -A 5`查看 test 可执行文件，并没有发现 @rpath 的值。

3. 没有查询到说明现在 test 现在还没有`@rpath`的值，使用`install_name_tool -add_rpath  可执行文件当前路径  可执行文件`进行添加
```
    install_name_tool -add_rpath /Users/xxx/Desktop/aaaa  test
```
4. 再次查看 test `@rpath`已经有值了，通过 lldb 进行加载可执行文件依然可以完美运行。但是这样依然没有解决绝对路径的问题，我们需要另一个参数`@executable_path`

##### 使用 @executable_path
`@executable_path`：表示可执⾏程序所在的⽬录，解析为可执⾏⽂件的绝对路径。

依然是上面的例子,我们通过下面的指令将可执行文件的`@rpath`修改为 `@executable_path`，使用 lldb 进行测试依然可以运行。这样就解决了绝对路径的问题。
```
    install_name_tool -rpath /Users/xxx/Desktop/aaaa @executable_path  test
```

* `@loader_path`：表示被加载的`Mach-O` 所在的⽬录，每次加载时，都可能
被设置为不同的路径，由上层指定。

## 动态库嵌套
当可执行文件引用了动态库A，动态库A又引用了动态库B，这种情况我们改怎么做呢？

举一个例子，test.m -> TestExample.m -> TestExampleLog.m，如下图：
![](../imgs/sdk/ios_sdk_22.png)
代码如下：
```objc
// test.m
#import <Foundation/Foundation.h>
#import "TestExample.h"
#import "TestExampleLog.h"
int main(){
    NSLog(@"testApp----");
    TestExample *manager = [TestExample new];
    [manager lg_test: nil];
    TestExampleLog *log = [TestExampleLog new];
    NSLog(@"testApp----%@",log);
    return 0;
}
// TestExample.m
#import "TestExample.h"
#import "TestExampleLog.h"
@implementation TestExample
- (void)lg_test:(_Nullable id)e {
    NSLog(@"TestExample----");
    TestExampleLog *log = [TestExampleLog new];
    [log test_example_log: self];
}
@end
// TestExampleLog.m
@implementation TestExampleLog
- (void)test_example_log:(_Nullable id)e {
    NSLog(@"TestExampleLog---%@", e);
}
@end
```
1. 首先需要将 `TestExampleLog.m` 编译成动态库
```shell
    # 先编译成.o
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -I./Headers \
    -c TestExampleLog.m -o TestExampleLog.o
    
    # 再编译成动态库
    clang -dynamiclib  \
    -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -Xlinker -install_name -Xlinker @rpath/TestExampleLog.framework/TestExampleLog \
    TestExampleLog.o -o TestExampleLog
```
2. 首先需要将 `TestExample.m` 编译成动态库
```shell
    # 先编译成.o
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -I./Headers \
    -I./Frameworks/TestExampleLog.framework/Headers \
    -c TestExample.m -o TestExample.o
    
    # 再编译成动态库
    clang -dynamiclib  \
    -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -Xlinker -install_name -Xlinker @rpath/TestExample.framework/TestExample \
    -Xlinker -rpath -Xlinker @loader_path/Frameworks \
    -Xlinker -reexport_framework -Xlinker TestExampleLog \
    -F./Frameworks \
    -framework TestExampleLog \
    TestExample.o -o TestExample
```
3. 首先需要将 `test.m` 编译成可执行文件
```shell
    # 先编译成.o
    clang -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -I./Frameworks/TestExample.framework/Headers \
    -I./Frameworks/TestExample.framework/Frameworks/TestExampleLog.framework/Headers \
    -c test.m -o test.o
    
    # 再编译成可执行文件
    clang   \
    -target x86_64-apple-macos11.1 \
    -fobjc-arc \
    -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.sdk \
    -Xlinker -rpath -Xlinker @executable_path/Frameworks \
    -F./Frameworks \
    -framework TestExample \
    test.o -o test
```

## tdb格式
tbd 全称是`text-based stub libraries`，本质上就是⼀个`YAML`描述的⽂本⽂
件。

他的作⽤是⽤于记录动态库的⼀些信息，包括导出的符号、动态库的架构信息、动
态库的依赖信息。

**⽤于避免在真机开发过程中直接使⽤传统的dylib**。

对于真机来说，由于动态库都是在设备上，在Xcode上使⽤基于tbd格式的伪framework可以⼤⼤减少Xcode的⼤⼩

## Framework
Mac OS/iOS 平台还可以使⽤ Framework。Framework 实际上是⼀种打包⽅式，将库的⼆进制⽂件，头⽂件和有关的资源⽂件打包到⼀起，⽅便管理和分发。

Framework 和系统的 `UIKit.Framework` 还是有很⼤区别。系统的 Framework 不需要拷⻉到⽬标程序中，我们⾃⼰做出来的 Framework 哪怕是动态的，最后也还是要拷⻉到 App 中 **（App 和 Extension 的 Bundle 是共享的）**，因此苹果⼜把这种 Framework 称为 `Embedded Framework`。

`Embedded Framework`:开发中使⽤的动态库会被放⼊到ipa下的framework⽬录下，基于沙盒运⾏。

不同的App使⽤相同的动态库，并不会只在系统中存在⼀份。⽽是会在多个App中各⾃打包、签名、加载⼀份。





